## 详细目录
***
### lesson1 排序算法 Sort Algorithm
1. 绪论 Introduction
   - 排序算法的分类（内部、外部）和八种内部排序
   - 时间频度 `T(n)` 算法中语句执行的次数
   - 时间复杂度（Time Complexity）的统计方法（事后统计法、事先估算法）、计算方法（记作O(f(n))，求执行次数函数的同数量级函数f(n)）
   - 常见的时间复杂度（常数阶、线性阶、线性对数阶、k次方阶、指数阶）
   - 平均时间复杂度和最坏时间复杂度
   - 空间复杂度（Space Complexity）
2. 冒泡排序 Bubble Sort
   - 基本思想
   - 优化（设置本轮冒泡是否发生的flag用来提前结束冒泡排序）
   - 时间复杂度 `O(n^2)` （两层for循环）
   - 实现简单，数据量大时，执行效率较低
3. 选择排序 Selection Sort
   - 基本思想（每一轮排序选择出最小的交换至头部）
   - 时间复杂度 `O(n^2)` (两层for循环)
   - 执行效率明显高于冒泡排序
4. 插入排序 Insertion Sort
   - 基本思想（将序列分为一个有序表和无序表，无序表的元素有序插入到有序表中）
   - 时间复杂度 `O(n^1~2)` (for循环内嵌套while循环，while循环次数小于问题规模n)
5. 希尔排序 Shell's Sort
   - 直接插入排序的问题（较小的元素插入时需多次移动）
   - 基本思想-缩小增量排序（增量分组内进行排序，缩小增量至0为止）
   - 希尔排序[交换法]：发现逆序交换元素的位置（低效率方法）
   - 希尔排序[移位法]：发现逆序在分组内插入排序（优化效率的方法）
   - 交换法和移位法的效率比较（交换法由于需要逐个比较交换位置效率低）
6. 快速排序 Quicksort
   - 基本思想 递归（将序列分为大于和小于一中间值的两部分，先左侧后右侧递归之，直至区间内仅有一个元素）
   - [中间数]：取下标位于区间正中的元素作为比较的中间值，交换值的方法进行分区
   - [挖坑填数]：取区间最左端元素的值作为中间值，最后获得中间值下标并分区
   - 时间复杂度 `O(nlogn)`
7. 归并排序 Merge Sort
   - 基本思想 分治 Divide and Conquer(先拆分问题递归求解，再将“分”阶段的解“修补”成整个问题的解答)
   - 实现方法 [分]：将原序列递归拆分成单个元素；[治]：在回溯时将两个序列合并为一个有序序列
   - 时间复杂度 `O(nlogn)` 空间复杂度 `T(n)`
8. 基数排序 Radix Sort
   - 属于分配式排序(distribution sort)，又称“桶排序”(bucket sort或bin sort)
   - 高效的稳定性算法(稳定性指等值的元素在排序前后的相对位置不变)
   - 基本思想 统一各数值位数(短的补0)，从低到高逐位进行排序之后得到有序序列
   - 空间复杂度高，海量数据（千万级别）排序会内存溢出
   - 若序列存在负数，则将序列拆分成负数和自然数序列，分别排序，在按各自顺序将元素插入原数组
9. 堆排序 Heap Sort
   - 知识预备 堆  
     （1）大/小顶堆，对于一颗完全二叉树，满足非叶子的关键字均大/小于其子节点（左右子节点的大小关系无要求）；  
     （2）在顺序存储的二叉树中，大顶堆满足：`arr[i] >= arr[2i + 1] && arr[i] >= arr[2i + 2]`
   - 时间复杂度为 `O(nlogn)`，是不稳定排序
   - 基本思想（升序）  
     （1）将待排序数组构造成一个大顶堆（二叉树采用顺序存储方式）；  
     （2）将堆顶元素（即堆的最大值）交换至序列尾部，完成一轮堆排序；  
     （3）对剩余的n-1个元素重复（1）和（2）直至堆只剩一个元素，排序完成。

***
### lesson2 查找算法 Search Algorithm
1. 二分查找 Binary Search
   - 思路：通过与中间值arr[mid]比较大小决定向左或向右递归，再去新的区间中取中间值
   - 注意递归结束的条件：匹配到元素；递归完整个数组，仍未找到
   - [改良]查找所有匹配的索引（在arr[mid]匹配之后，向左、向右匹配与arr[mid]等值的元素，将匹配的索引及mid放入集合并return）
2. 插值查找 Interpolation Search
   - 思路：自适应的定义中间索引mid  
     `int mid = left + (right - left) * (val - arr[left]) / (arr[right] - arr[left])`
   - 适用情况：数据较大、关键字分布比较均匀
3. 斐波那契查找 Fibonacci Search
   - 预备知识  
     黄金分割（中外比）：将线段L分为L1、L2两端，使得`L1/L = L2/L1`，比值约为0.618  
     斐波那契数列：{1,1,2,3,5,8,13,21,34,55,......}，相邻两项的比值无限趋近于黄金比例
   - 原理：根据斐波那契数列以及黄金分割定位mid的位置  
     由斐波那契数列 `F(k) = F(k-1) + F(k-2)` 的性质推得 `F(k)-1 = [F(k-1)-1] + [F(k-2)-2] + 1`；  
     将长度为F(k)-1的顺序表分为F(k-1)-1和F(k-2)-1两段，中间的1即为mid => `mid = low + F(k-1) - 1`
   - 实际操作：顺序的长度n不一定等于F(k)-1，所以需要对原顺序表进行扩容，使长度增至F(k)-1  
     此处的k只需使F(k)-1恰好大于或等于n，k的求法为  `while(f(k) - 1 < n) { k++; }`